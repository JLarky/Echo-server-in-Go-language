# Зачем

Суть в том, что на каждого подключившегося клиента запускается свой слушатель сокета listen_socket, соотвественно если несколько клиентов будут писать одновременно, то обрабатываться эти данные будут тоже одновременно (хотя честно говоря понятия не имеют так ли это с точки зрения Go).

Точно так же функция handle запускается не зависимо от других клиентов и собствено говоря пакетов одного и того же сокета. Единственное что гарантируется касательно очерёдности обработки пакетов одного сокета это то, что форк (go handle) процесса обработки будет в порядке прихода пакетов (что собственно говоря не должно даже гарантировать что первый форкнувшийся запустится первым).

Это поведение можно легко испортить если убрать слово "go" из строчки "go handle( <- data_ch );" и решать когда форкаться уже внутри handle. Это если вам вдруг важно в каком порядке обрабатывать данные, но это уже другая история.

# Ну так и зачем?

Чтобы выпендриться. Попоробуйте написать это на вашем любимом языке (кроме Erlang) то, что тут делается через каналы и go.

# Как запустить

    make

# Как проверить, что работает

написать что-нибудь в порт 4321
например сделать
    netcat localhost 4321